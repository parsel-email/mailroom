// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: email.sql

package schema

import (
	"context"
	"database/sql"
)

const createEmail = `-- name: CreateEmail :one
INSERT INTO email (
    user_id,
    thread_id,
    gmail_message_id,
    raw_mime_content,
    snippet,
    is_read,
    is_starred
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, user_id, thread_id, gmail_message_id, raw_mime_content, snippet, is_read, is_starred, created_at, updated_at, server_timestamp
`

type CreateEmailParams struct {
	UserID         int64          `json:"user_id"`
	ThreadID       sql.NullInt64  `json:"thread_id"`
	GmailMessageID string         `json:"gmail_message_id"`
	RawMimeContent string         `json:"raw_mime_content"`
	Snippet        sql.NullString `json:"snippet"`
	IsRead         sql.NullBool   `json:"is_read"`
	IsStarred      sql.NullBool   `json:"is_starred"`
}

func (q *Queries) CreateEmail(ctx context.Context, arg CreateEmailParams) (Email, error) {
	row := q.db.QueryRowContext(ctx, createEmail,
		arg.UserID,
		arg.ThreadID,
		arg.GmailMessageID,
		arg.RawMimeContent,
		arg.Snippet,
		arg.IsRead,
		arg.IsStarred,
	)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ThreadID,
		&i.GmailMessageID,
		&i.RawMimeContent,
		&i.Snippet,
		&i.IsRead,
		&i.IsStarred,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ServerTimestamp,
	)
	return i, err
}

const deleteEmail = `-- name: DeleteEmail :exec
DELETE FROM email WHERE id = ?
`

func (q *Queries) DeleteEmail(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEmail, id)
	return err
}

const getEmailByID = `-- name: GetEmailByID :one
SELECT id, user_id, thread_id, gmail_message_id, raw_mime_content, snippet, is_read, is_starred, created_at, updated_at, server_timestamp FROM email WHERE id = ?
`

func (q *Queries) GetEmailByID(ctx context.Context, id int64) (Email, error) {
	row := q.db.QueryRowContext(ctx, getEmailByID, id)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ThreadID,
		&i.GmailMessageID,
		&i.RawMimeContent,
		&i.Snippet,
		&i.IsRead,
		&i.IsStarred,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ServerTimestamp,
	)
	return i, err
}

const listEmails = `-- name: ListEmails :many
SELECT id, user_id, thread_id, gmail_message_id, raw_mime_content, snippet, is_read, is_starred, created_at, updated_at, server_timestamp FROM email
WHERE user_id = COALESCE(?, user_id)
  AND is_read = COALESCE(?, is_read)
  AND is_starred = COALESCE(?, is_starred)
ORDER BY created_at DESC
LIMIT COALESCE(?, 100)
OFFSET COALESCE(?, 0)
`

type ListEmailsParams struct {
	UserID    int64        `json:"user_id"`
	IsRead    sql.NullBool `json:"is_read"`
	IsStarred sql.NullBool `json:"is_starred"`
	Column4   interface{}  `json:"column_4"`
	Column5   interface{}  `json:"column_5"`
}

func (q *Queries) ListEmails(ctx context.Context, arg ListEmailsParams) ([]Email, error) {
	rows, err := q.db.QueryContext(ctx, listEmails,
		arg.UserID,
		arg.IsRead,
		arg.IsStarred,
		arg.Column4,
		arg.Column5,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Email{}
	for rows.Next() {
		var i Email
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ThreadID,
			&i.GmailMessageID,
			&i.RawMimeContent,
			&i.Snippet,
			&i.IsRead,
			&i.IsStarred,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ServerTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmail = `-- name: UpdateEmail :one
UPDATE email
SET
    thread_id = ?,
    raw_mime_content = ?,
    snippet = ?,
    is_read = ?,
    is_starred = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, user_id, thread_id, gmail_message_id, raw_mime_content, snippet, is_read, is_starred, created_at, updated_at, server_timestamp
`

type UpdateEmailParams struct {
	ThreadID       sql.NullInt64  `json:"thread_id"`
	RawMimeContent string         `json:"raw_mime_content"`
	Snippet        sql.NullString `json:"snippet"`
	IsRead         sql.NullBool   `json:"is_read"`
	IsStarred      sql.NullBool   `json:"is_starred"`
	ID             int64          `json:"id"`
}

func (q *Queries) UpdateEmail(ctx context.Context, arg UpdateEmailParams) (Email, error) {
	row := q.db.QueryRowContext(ctx, updateEmail,
		arg.ThreadID,
		arg.RawMimeContent,
		arg.Snippet,
		arg.IsRead,
		arg.IsStarred,
		arg.ID,
	)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ThreadID,
		&i.GmailMessageID,
		&i.RawMimeContent,
		&i.Snippet,
		&i.IsRead,
		&i.IsStarred,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ServerTimestamp,
	)
	return i, err
}
